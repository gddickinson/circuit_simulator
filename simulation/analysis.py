"""Circuit Simulator - Circuit Analysis---------------------------------This module provides analysis tools for evaluating circuits.It supports DC, AC, transient, and other types of analysis."""import loggingimport timeimport numpy as npimport mathfrom collections import defaultdictimport configfrom utils.logger import SimulationEventlogger = logging.getLogger(__name__)class CircuitAnalysis:    """Class for performing circuit analysis."""    def __init__(self, simulator):        """Initialize the circuit analyzer.        Args:            simulator: CircuitSimulator instance        """        self.simulator = simulator    def dc_analysis(self):        """Perform DC analysis of the circuit.        This calculates the steady-state DC operating point of the circuit.        Returns:            Dictionary of results        """        logger.info("Starting DC analysis")        # Store the original simulation state        original_time = self.simulator.simulation_time        original_history = self.simulator.history        original_running = self.simulator.running        original_paused = self.simulator.paused        # Reset the simulator        self.simulator.reset_simulation()        # Run the simulation for a short time to reach steady state        self.simulator.start_simulation()        # Capture start time        start_time = time.time()        # Run for a fixed number of steps or until convergence        max_steps = 100        convergence_threshold = 1e-6        converged = False        for step in range(max_steps):            # Update the simulation            self.simulator.update()            # Check for convergence            # For now, just go through all steps            # TODO: Implement proper convergence check            # For demonstration, consider converged after 50 steps            if step >= 50:                converged = True                break        # Capture end time        end_time = time.time()        # Stop the simulation        self.simulator.stop_simulation()        # Collect results        results = {            'node_voltages': {},            'component_currents': {},            'component_powers': {},            'converged': converged,            'iterations': step + 1,            'time_taken': end_time - start_time        }        # Node voltages        for node_id, node in self.simulator.nodes.items():            results['node_voltages'][node_id] = node.voltage        # Component currents and powers        for component_id, component in self.simulator.components.items():            # Get currents for each connection            results['component_currents'][component_id] = {}            for connection_name in component.connections:                current = component.get_current(connection_name)                if current is not None:                    results['component_currents'][component_id][connection_name] = current            # Get power            power = component.state.get('power', 0.0)            results['component_powers'][component_id] = power        # Restore the simulator state        self.simulator.simulation_time = original_time        self.simulator.history = original_history        self.simulator.running = original_running        self.simulator.paused = original_paused        logger.info(f"DC analysis completed in {results['time_taken']:.3f} seconds")        return results    def ac_analysis(self, start_freq, end_freq, num_points, scale='log'):        """Perform AC analysis of the circuit.        This calculates the frequency response of the circuit over a range of frequencies.        Args:            start_freq: Start frequency in Hz            end_freq: End frequency in Hz            num_points: Number of frequency points            scale: Frequency scale ('log' or 'linear')        Returns:            Dictionary of results        """        logger.info(f"Starting AC analysis from {start_freq}Hz to {end_freq}Hz")        # Store the original simulation state        original_time = self.simulator.simulation_time        original_history = self.simulator.history        original_running = self.simulator.running        original_paused = self.simulator.paused        # Generate frequency points        if scale == 'log':            frequencies = np.logspace(np.log10(start_freq), np.log10(end_freq), num_points)        else:            frequencies = np.linspace(start_freq, end_freq, num_points)        # Results structure        results = {            'frequencies': frequencies,            'node_voltages': defaultdict(list),            'component_currents': defaultdict(lambda: defaultdict(list)),            'component_impedances': defaultdict(list),            'time_taken': 0.0        }        # Capture start time        start_time = time.time()        # For each frequency, calculate the response        for freq in frequencies:            # Reset the simulator            self.simulator.reset_simulation()            # Set all AC sources to the current frequency            for component_id, component in self.simulator.components.items():                if component.__class__.__name__ == 'ACVoltageSource':                    component.set_property('frequency', freq)            # Run the simulation for a few cycles to reach steady state            self.simulator.start_simulation()            # Calculate the period            period = 1.0 / freq            # Run for 5 periods            simulation_time = 5 * period            # Run the simulation in steps            while self.simulator.simulation_time < simulation_time:                self.simulator.update()            # Collect results at this frequency            # Node voltages            for node_id, node in self.simulator.nodes.items():                results['node_voltages'][node_id].append(node.voltage)            # Component currents and impedances            for component_id, component in self.simulator.components.items():                # Get currents for each connection                for connection_name in component.connections:                    current = component.get_current(connection_name)                    if current is not None:                        results['component_currents'][component_id][connection_name].append(current)                # Calculate impedance (if applicable)                if component.__class__.__name__ in ['Resistor', 'Capacitor', 'Inductor']:                    # For a resistor, impedance is just resistance                    if component.__class__.__name__ == 'Resistor':                        impedance = component.get_property('resistance', config.DEFAULT_RESISTANCE)                    # For a capacitor, impedance is 1/(jwC)                    elif component.__class__.__name__ == 'Capacitor':                        capacitance = component.get_property('capacitance', config.DEFAULT_CAPACITANCE)                        impedance = 1.0 / (2.0 * math.pi * freq * capacitance * 1j)                    # For an inductor, impedance is jwL                    elif component.__class__.__name__ == 'Inductor':                        inductance = component.get_property('inductance', config.DEFAULT_INDUCTANCE)                        impedance = 2.0 * math.pi * freq * inductance * 1j                    # Store the impedance magnitude                    results['component_impedances'][component_id].append(abs(impedance))        # Stop the simulation        self.simulator.stop_simulation()        # Capture end time        end_time = time.time()        results['time_taken'] = end_time - start_time        # Restore the simulator state        self.simulator.simulation_time = original_time        self.simulator.history = original_history        self.simulator.running = original_running        self.simulator.paused = original_paused        logger.info(f"AC analysis completed in {results['time_taken']:.3f} seconds")        return results    def transient_analysis(self, start_time, end_time, time_step=None):        """Perform transient analysis of the circuit.        This simulates the circuit's behavior over time.        Args:            start_time: Start time in seconds            end_time: End time in seconds            time_step: Time step in seconds (if None, use simulator default)        Returns:            Dictionary of results        """        logger.info(f"Starting transient analysis from {start_time}s to {end_time}s")        # Store the original simulation state        original_time = self.simulator.simulation_time        original_history = self.simulator.history        original_running = self.simulator.running        original_paused = self.simulator.paused        # Set up time step        if time_step is None:            time_step = self.simulator.time_step        # Results structure        results = {            'times': [],            'node_voltages': defaultdict(list),            'component_currents': defaultdict(lambda: defaultdict(list)),            'component_powers': defaultdict(list),            'time_taken': 0.0        }        # Reset the simulator        self.simulator.reset_simulation()        # Run the simulation through the specified time range        self.simulator.simulation_time = start_time        # Start the simulation        self.simulator.start_simulation()        # Capture start time        start_time_real = time.time()        # Run the simulation        while self.simulator.simulation_time < end_time:            # Update the simulation            self.simulator.update()            # Record the current time            results['times'].append(self.simulator.simulation_time)            # Node voltages            for node_id, node in self.simulator.nodes.items():                results['node_voltages'][node_id].append(node.voltage)            # Component currents and powers            for component_id, component in self.simulator.components.items():                # Get currents for each connection                for connection_name in component.connections:                    current = component.get_current(connection_name)                    if current is not None:                        results['component_currents'][component_id][connection_name].append(current)                # Get power                power = component.state.get('power', 0.0)                results['component_powers'][component_id].append(power)        # Stop the simulation        self.simulator.stop_simulation()        # Capture end time        end_time_real = time.time()        results['time_taken'] = end_time_real - start_time_real        # Restore the simulator state        self.simulator.simulation_time = original_time        self.simulator.history = original_history        self.simulator.running = original_running        self.simulator.paused = original_paused        logger.info(f"Transient analysis completed in {results['time_taken']:.3f} seconds")        return results    def dc_sweep(self, component_id, property_name, start_value, end_value, num_points):        """Perform a DC sweep analysis.        This performs multiple DC analyses while sweeping a component property.        Args:            component_id: ID of the component to sweep            property_name: Name of the property to sweep            start_value: Start value            end_value: End value            num_points: Number of points in the sweep        Returns:            Dictionary of results        """        logger.info(f"Starting DC sweep of {component_id}.{property_name} from {start_value} to {end_value}")        # Get the component        component = self.simulator.components.get(component_id)        if not component:            logger.error(f"Component {component_id} not found")            return None        # Store the original property value        original_value = component.get_property(property_name)        # Generate sweep points        sweep_values = np.linspace(start_value, end_value, num_points)        # Results structure        results = {            'sweep_property': property_name,            'sweep_values': sweep_values,            'node_voltages': defaultdict(list),            'component_currents': defaultdict(lambda: defaultdict(list)),            'component_powers': defaultdict(list),            'time_taken': 0.0        }        # Capture start time        start_time = time.time()        # For each sweep point, run a DC analysis        for value in sweep_values:            # Set the component property            component.set_property(property_name, value)            # Run DC analysis            dc_results = self.dc_analysis()            # Extract results            for node_id, voltage in dc_results['node_voltages'].items():                results['node_voltages'][node_id].append(voltage)            for comp_id, currents in dc_results['component_currents'].items():                for conn_name, current in currents.items():                    results['component_currents'][comp_id][conn_name].append(current)            for comp_id, power in dc_results['component_powers'].items():                results['component_powers'][comp_id].append(power)        # Restore the original property value        component.set_property(property_name, original_value)        # Capture end time        end_time = time.time()        results['time_taken'] = end_time - start_time        logger.info(f"DC sweep completed in {results['time_taken']:.3f} seconds")        return results    def calculate_network_parameters(self):        """Calculate network parameters of the circuit.        This calculates parameters like input impedance, voltage gain, etc.        Returns:            Dictionary of results        """        logger.info("Calculating network parameters")        # TODO: Implement calculation of network parameters        # For now, return a placeholder        results = {            'input_impedance': 0.0,            'output_impedance': 0.0,            'voltage_gain': 0.0,            'current_gain': 0.0,            'power_gain': 0.0        }        logger.info("Network parameter calculation complete")        return results    def noise_analysis(self, start_freq, end_freq, num_points):        """Perform noise analysis of the circuit.        This calculates the noise contribution of different components.        Args:            start_freq: Start frequency in Hz            end_freq: End frequency in Hz            num_points: Number of frequency points        Returns:            Dictionary of results        """        logger.info(f"Starting noise analysis from {start_freq}Hz to {end_freq}Hz")        # TODO: Implement noise analysis        # For now, return a placeholder        results = {            'frequencies': np.logspace(np.log10(start_freq), np.log10(end_freq), num_points),            'input_noise': np.zeros(num_points),            'output_noise': np.zeros(num_points),            'component_noise': {}        }        logger.info("Noise analysis complete")        return results    def sensitivity_analysis(self, output_node_id, parameters):        """Perform sensitivity analysis.        This calculates how sensitive an output is to parameter variations.        Args:            output_node_id: ID of the output node            parameters: List of (component_id, property_name) tuples        Returns:            Dictionary of results        """        logger.info(f"Starting sensitivity analysis for {output_node_id}")        # TODO: Implement sensitivity analysis        # For now, return a placeholder        results = {            'output_node': output_node_id,            'sensitivities': {}        }        for component_id, property_name in parameters:            results['sensitivities'][(component_id, property_name)] = 0.0        logger.info("Sensitivity analysis complete")        return results    def monte_carlo_analysis(self, num_runs, parameters, analysis_type='dc'):        """Perform Monte Carlo analysis.        This runs multiple analyses with randomized parameter values.        Args:            num_runs: Number of simulation runs            parameters: List of (component_id, property_name, mean, std_dev) tuples            analysis_type: Type of analysis to perform ('dc', 'ac', 'transient')        Returns:            Dictionary of results        """        logger.info(f"Starting Monte Carlo analysis with {num_runs} runs")        # TODO: Implement Monte Carlo analysis        # For now, return a placeholder        results = {            'num_runs': num_runs,            'analysis_type': analysis_type,            'parameters': parameters,            'runs': []        }        logger.info("Monte Carlo analysis complete")        return results