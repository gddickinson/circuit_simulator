"""Circuit Simulator - Circuit Parser--------------------------------This module provides utilities for parsing and writing circuit filesin various formats, including the native .circuit format, as well asimport/export of other common formats like SPICE netlists."""import osimport jsonimport loggingimport xml.etree.ElementTree as ETfrom pathlib import Pathfrom components.base_component import BaseComponentfrom components.passive_components import Resistor, Capacitor, Inductor, Groundfrom components.active_components import (    DCVoltageSource, ACVoltageSource, DCCurrentSource, Diode, LED, BJT, Switch)import configlogger = logging.getLogger(__name__)class CircuitParser:    """Parser and writer for circuit files."""    def __init__(self, simulator, db_manager=None):        """Initialize the circuit parser.        Args:            simulator: CircuitSimulator instance            db_manager: DatabaseManager instance (optional)        """        self.simulator = simulator        self.db_manager = db_manager    def save_to_file(self, file_path, metadata=None):        """Save the circuit to a file.        Args:            file_path: Path to save the file to            metadata: Optional metadata dictionary        Returns:            True if successful, False otherwise        """        # Determine file format based on extension        ext = os.path.splitext(file_path)[1].lower()        if ext == '.circuit':            return self._save_native_format(file_path, metadata)        elif ext == '.spice' or ext == '.net':            return self._save_spice_format(file_path)        elif ext == '.json':            return self._save_json_format(file_path, metadata)        elif ext == '.xml':            return self._save_xml_format(file_path, metadata)        else:            logger.error(f"Unsupported file format: {ext}")            return False    def load_from_file(self, file_path):        """Load a circuit from a file.        Args:            file_path: Path to the file to load        Returns:            Tuple of (success, metadata) where:                success: True if successful, False otherwise                metadata: Dictionary of metadata if available, None otherwise        """        # Determine file format based on extension        ext = os.path.splitext(file_path)[1].lower()        if ext == '.circuit':            return self._load_native_format(file_path)        elif ext == '.spice' or ext == '.net':            return self._load_spice_format(file_path)        elif ext == '.json':            return self._load_json_format(file_path)        elif ext == '.xml':            return self._load_xml_format(file_path)        else:            logger.error(f"Unsupported file format: {ext}")            return False, None    def _save_native_format(self, file_path, metadata=None):        """Save the circuit in native .circuit format.        Args:            file_path: Path to save the file to            metadata: Optional metadata dictionary        Returns:            True if successful, False otherwise        """        try:            # Convert circuit to dictionary            circuit_data = self.simulator.to_dict()            # Add metadata            if metadata:                circuit_data['metadata'] = metadata            else:                circuit_data['metadata'] = {                    'name': os.path.basename(file_path).split('.')[0],                    'description': '',                    'author': '',                    'created_at': '',                    'modified_at': ''                }            # Write to file            with open(file_path, 'w') as f:                json.dump(circuit_data, f, indent=2)            logger.info(f"Saved circuit to {file_path}")            return True        except Exception as e:            logger.error(f"Error saving circuit to {file_path}: {e}")            return False    def _load_native_format(self, file_path):        """Load a circuit from native .circuit format.        Args:            file_path: Path to the file to load        Returns:            Tuple of (success, metadata) where:                success: True if successful, False otherwise                metadata: Dictionary of metadata if available, None otherwise        """        try:            # Read from file            with open(file_path, 'r') as f:                circuit_data = json.load(f)            # Extract metadata            metadata = circuit_data.get('metadata', {})            # Create components from the data            self._create_circuit_from_dict(circuit_data)            logger.info(f"Loaded circuit from {file_path}")            return True, metadata        except Exception as e:            logger.error(f"Error loading circuit from {file_path}: {e}")            return False, None    def _save_json_format(self, file_path, metadata=None):        """Save the circuit in JSON format.        Args:            file_path: Path to save the file to            metadata: Optional metadata dictionary        Returns:            True if successful, False otherwise        """        # JSON format is similar to native format        return self._save_native_format(file_path, metadata)    def _load_json_format(self, file_path):        """Load a circuit from JSON format.        Args:            file_path: Path to the file to load        Returns:            Tuple of (success, metadata) where:                success: True if successful, False otherwise                metadata: Dictionary of metadata if available, None otherwise        """        # JSON format is similar to native format        return self._load_native_format(file_path)    def _save_xml_format(self, file_path, metadata=None):        """Save the circuit in XML format.        Args:            file_path: Path to save the file to            metadata: Optional metadata dictionary        Returns:            True if successful, False otherwise        """        try:            # Create root element            root = ET.Element("circuit")            # Add metadata            meta_elem = ET.SubElement(root, "metadata")            meta = metadata or {                'name': os.path.basename(file_path).split('.')[0],                'description': '',                'author': '',                'created_at': '',                'modified_at': ''            }            for key, value in meta.items():                meta_elem.set(key, str(value))            # Add components            components_elem = ET.SubElement(root, "components")            for component_id, component in self.simulator.components.items():                comp_elem = ET.SubElement(components_elem, "component")                comp_elem.set("id", component_id)                comp_elem.set("type", component.__class__.__name__)                # Position and rotation                pos_elem = ET.SubElement(comp_elem, "position")                pos_elem.set("x", str(component.position[0]))                pos_elem.set("y", str(component.position[1]))                comp_elem.set("rotation", str(component.rotation))                # Properties                props_elem = ET.SubElement(comp_elem, "properties")                for key, value in component.properties.items():                    prop_elem = ET.SubElement(props_elem, "property")                    prop_elem.set("name", key)                    prop_elem.set("value", str(value))                # Connections                conns_elem = ET.SubElement(comp_elem, "connections")                for conn_name, (other_id, other_conn) in component.connected_to.items():                    conn_elem = ET.SubElement(conns_elem, "connection")                    conn_elem.set("from", conn_name)                    conn_elem.set("to_component", other_id)                    conn_elem.set("to_connection", other_conn)            # Write to file            tree = ET.ElementTree(root)            tree.write(file_path, encoding="utf-8", xml_declaration=True)            logger.info(f"Saved circuit to {file_path}")            return True        except Exception as e:            logger.error(f"Error saving circuit to {file_path}: {e}")            return False    def _load_xml_format(self, file_path):        """Load a circuit from XML format.        Args:            file_path: Path to the file to load        Returns:            Tuple of (success, metadata) where:                success: True if successful, False otherwise                metadata: Dictionary of metadata if available, None otherwise        """        try:            # Parse XML file            tree = ET.parse(file_path)            root = tree.getroot()            # Extract metadata            meta_elem = root.find("metadata")            metadata = {key: value for key, value in meta_elem.attrib.items()}            # Clear existing circuit            self.simulator.clear()            # Create components            components_elem = root.find("components")            component_dict = {}            for comp_elem in components_elem.findall("component"):                component_id = comp_elem.get("id")                component_type = comp_elem.get("type")                # Get position and rotation                pos_elem = comp_elem.find("position")                x = int(pos_elem.get("x"))                y = int(pos_elem.get("y"))                rotation = int(comp_elem.get("rotation"))                # Get properties                properties = {}                props_elem = comp_elem.find("properties")                for prop_elem in props_elem.findall("property"):                    name = prop_elem.get("name")                    value = prop_elem.get("value")                    # Convert value to appropriate type                    if value.lower() in ("true", "false"):                        value = value.lower() == "true"                    else:                        try:                            value = float(value)                            # Convert to int if it's a whole number                            if value.is_integer():                                value = int(value)                        except ValueError:                            # Keep as string                            pass                    properties[name] = value                # Create component                component = self._create_component(component_type, properties)                if component:                    # Set ID, position, and rotation                    component.id = component_id                    component.position = (x, y)                    component.set_rotation(rotation)                    # Add to simulator                    self.simulator.add_component(component)                    # Store for connection setup                    component_dict[component_id] = component            # Create connections            for comp_elem in components_elem.findall("component"):                component_id = comp_elem.get("id")                component = component_dict.get(component_id)                if not component:                    continue                conns_elem = comp_elem.find("connections")                if conns_elem is None:                    continue                for conn_elem in conns_elem.findall("connection"):                    from_conn = conn_elem.get("from")                    to_id = conn_elem.get("to_component")                    to_conn = conn_elem.get("to_connection")                    other_component = component_dict.get(to_id)                    if other_component:                        self.simulator.connect_components_at(                            component.id, from_conn,                            other_component.id, to_conn                        )            logger.info(f"Loaded circuit from {file_path}")            return True, metadata        except Exception as e:            logger.error(f"Error loading circuit from {file_path}: {e}")            return False, None    def _save_spice_format(self, file_path):        """Save the circuit in SPICE netlist format.        Args:            file_path: Path to save the file to        Returns:            True if successful, False otherwise        """        try:            # Create netlist string            netlist = []            # Title line            title = os.path.basename(file_path).split('.')[0]            netlist.append(f"* {title} - Generated by Circuit Simulator")            netlist.append("* " + "-" * 60)            netlist.append("")            # Add components            for component_id, component in self.simulator.components.items():                # Skip ground components (handled differently in SPICE)                if component.__class__.__name__ == 'Ground':                    continue                # Get component type and connections                spice_line = self._component_to_spice(component)                if spice_line:                    netlist.append(spice_line)            # End of netlist            netlist.append("")            netlist.append(".end")            # Write to file            with open(file_path, 'w') as f:                f.write('\n'.join(netlist))            logger.info(f"Saved SPICE netlist to {file_path}")            return True        except Exception as e:            logger.error(f"Error saving SPICE netlist to {file_path}: {e}")            return False    def _load_spice_format(self, file_path):        """Load a circuit from SPICE netlist format.        Args:            file_path: Path to the file to load        Returns:            Tuple of (success, metadata) where:                success: True if successful, False otherwise                metadata: Dictionary of metadata if available, None otherwise        """        try:            # Read netlist file            with open(file_path, 'r') as f:                lines = f.readlines()            # Extract title from first line            title = ""            if lines and lines[0].startswith('*'):                title = lines[0][1:].strip()            # Metadata            metadata = {                'name': title or os.path.basename(file_path).split('.')[0],                'description': '',                'author': '',                'created_at': '',                'modified_at': ''            }            # Clear existing circuit            self.simulator.clear()            # Create components            for line in lines:                # Skip comments and empty lines                line = line.strip()                if not line or line.startswith('*') or line.startswith('.'):                    continue                # Parse component line                component = self._spice_to_component(line)                if component:                    self.simulator.add_component(component)            # Create connections (handled by the simulator during component creation)            logger.info(f"Loaded SPICE netlist from {file_path}")            return True, metadata        except Exception as e:            logger.error(f"Error loading SPICE netlist from {file_path}: {e}")            return False, None    def _component_to_spice(self, component):        """Convert a component to a SPICE netlist line.        Args:            component: Component object        Returns:            SPICE netlist line or None if not supported        """        component_type = component.__class__.__name__        # Get node names for connections        connections = {}        for conn_name, conn_to in component.connected_to.items():            if conn_to:                other_id, other_conn = conn_to                node_name = f"N{hash(other_id + '_' + other_conn) % 1000}"                connections[conn_name] = node_name            else:                # Unconnected terminal                connections[conn_name] = "0"  # Ground in SPICE        if component_type == 'Resistor':            # Format: RXXXX N1 N2 VALUE            n1 = connections.get('p1', '0')            n2 = connections.get('p2', '0')            resistance = component.get_property('resistance', config.DEFAULT_RESISTANCE)            return f"R{component.id[:5]} {n1} {n2} {resistance}"        elif component_type == 'Capacitor':            # Format: CXXXX N1 N2 VALUE            n1 = connections.get('p1', '0')            n2 = connections.get('p2', '0')            capacitance = component.get_property('capacitance', config.DEFAULT_CAPACITANCE)            return f"C{component.id[:5]} {n1} {n2} {capacitance}"        elif component_type == 'Inductor':            # Format: LXXXX N1 N2 VALUE            n1 = connections.get('p1', '0')            n2 = connections.get('p2', '0')            inductance = component.get_property('inductance', config.DEFAULT_INDUCTANCE)            return f"L{component.id[:5]} {n1} {n2} {inductance}"        elif component_type == 'DCVoltageSource':            # Format: VXXXX N+ N- DC VALUE            n_pos = connections.get('pos', '0')            n_neg = connections.get('neg', '0')            voltage = component.get_property('voltage', config.DEFAULT_VOLTAGE)            return f"V{component.id[:5]} {n_pos} {n_neg} DC {voltage}"        elif component_type == 'ACVoltageSource':            # Format: VXXXX N+ N- AC AMPLITUDE FREQUENCY            n_pos = connections.get('pos', '0')            n_neg = connections.get('neg', '0')            amplitude = component.get_property('amplitude', config.DEFAULT_VOLTAGE)            frequency = component.get_property('frequency', config.DEFAULT_FREQUENCY)            return f"V{component.id[:5]} {n_pos} {n_neg} AC {amplitude} {frequency}"        elif component_type == 'DCCurrentSource':            # Format: IXXXX N+ N- DC VALUE            n_pos = connections.get('pos', '0')            n_neg = connections.get('neg', '0')            current = component.get_property('current', config.DEFAULT_CURRENT)            return f"I{component.id[:5]} {n_pos} {n_neg} DC {current}"        elif component_type == 'Diode':            # Format: DXXXX N+ N- MODEL            n_anode = connections.get('anode', '0')            n_cathode = connections.get('cathode', '0')            return f"D{component.id[:5]} {n_anode} {n_cathode} DIODE"        # Other components may not have direct SPICE equivalents or require more complex modeling        return None    def _spice_to_component(self, spice_line):        """Convert a SPICE netlist line to a component.        Args:            spice_line: SPICE netlist line        Returns:            Component object or None if not supported        """        # Split line into tokens        tokens = spice_line.split()        if not tokens:            return None        # Extract component type from first character        component_type = tokens[0][0].upper()        component_name = tokens[0]        # Parse component based on type        if component_type == 'R':            # Resistor: RXXXX N1 N2 VALUE            if len(tokens) >= 4:                resistance = float(tokens[3])                component = Resistor(properties={'resistance': resistance})                return component        elif component_type == 'C':            # Capacitor: CXXXX N1 N2 VALUE            if len(tokens) >= 4:                capacitance = float(tokens[3])                component = Capacitor(properties={'capacitance': capacitance})                return component        elif component_type == 'L':            # Inductor: LXXXX N1 N2 VALUE            if len(tokens) >= 4:                inductance = float(tokens[3])                component = Inductor(properties={'inductance': inductance})                return component        elif component_type == 'V':            # Voltage Source: VXXXX N+ N- TYPE VALUE...            if len(tokens) >= 5:                source_type = tokens[3].upper()                if source_type == 'DC':                    voltage = float(tokens[4])                    component = DCVoltageSource(properties={'voltage': voltage})                    return component                elif source_type == 'AC':                    amplitude = float(tokens[4])                    frequency = float(tokens[5]) if len(tokens) >= 6 else config.DEFAULT_FREQUENCY                    component = ACVoltageSource(properties={                        'amplitude': amplitude,                        'frequency': frequency                    })                    return component        elif component_type == 'I':            # Current Source: IXXXX N+ N- TYPE VALUE            if len(tokens) >= 5:                source_type = tokens[3].upper()                if source_type == 'DC':                    current = float(tokens[4])                    component = DCCurrentSource(properties={'current': current})                    return component        elif component_type == 'D':            # Diode: DXXXX N+ N- MODEL            component = Diode()            return component        # Unsupported or unrecognized component        logger.warning(f"Unsupported SPICE component: {spice_line}")        return None    def _create_circuit_from_dict(self, circuit_data):        """Create a circuit from a dictionary.        Args:            circuit_data: Dictionary containing circuit data        Returns:            True if successful, False otherwise        """        try:            # Clear existing circuit            self.simulator.clear()            # Get components data            components_data = circuit_data.get('components', {})            # Create and add components            for component_id, data in components_data.items():                # Extract component type                component_type = None                for key, value in data.items():                    if key.endswith('__class__'):                        component_type = value                        break                if not component_type:                    logger.warning(f"Component {component_id} has no type, skipping")                    continue                # Create component                component_factory = self._get_component_factory()                component = component_factory(data)                if component:                    # Add to simulator                    self.simulator.add_component(component)            # Build the circuit (this will create connections between components)            self.simulator.build_circuit_from_components()            # Set the ground node            ground_node_id = circuit_data.get('ground_node')            if ground_node_id and ground_node_id in self.simulator.nodes:                self.simulator.ground_node = self.simulator.nodes[ground_node_id]                self.simulator.ground_node.voltage = 0.0            return True        except Exception as e:            logger.error(f"Error creating circuit from dictionary: {e}")            return False    def _create_component(self, component_type, properties=None):        """Create a component of the given type.        Args:            component_type: Component type string (class name)            properties: Optional dictionary of component properties        Returns:            Component object or None if creation failed        """        try:            if component_type == "Resistor":                return Resistor(properties=properties)            elif component_type == "Capacitor":                return Capacitor(properties=properties)            elif component_type == "Inductor":                return Inductor(properties=properties)            elif component_type == "Ground":                return Ground(properties=properties)            elif component_type == "DCVoltageSource":                return DCVoltageSource(properties=properties)            elif component_type == "ACVoltageSource":                return ACVoltageSource(properties=properties)            elif component_type == "DCCurrentSource":                return DCCurrentSource(properties=properties)            elif component_type == "Diode":                return Diode(properties=properties)            elif component_type == "LED":                return LED(properties=properties)            elif component_type == "BJT":                return BJT(properties=properties)            elif component_type == "Switch":                return Switch(properties=properties)            else:                logger.error(f"Unknown component type: {component_type}")                return None        except Exception as e:            logger.error(f"Error creating component of type {component_type}: {e}")            return None    def _get_component_factory(self):        """Get a factory function for creating components from dictionary data.        Returns:            Function that takes component data and returns a component object        """        def create_component_from_dict(data):            # Get component type and properties            component_type = None            component_id = None            position = (0, 0)            rotation = 0            properties = {}            # Extract base properties            for key, value in data.items():                if key == 'id':                    component_id = value                elif key.endswith('__class__'):                    component_type = value                elif key == 'position':                    position = tuple(value)                elif key == 'rotation':                    rotation = value                elif key == 'properties':                    properties = value            # Create the component            component = self._create_component(component_type, properties)            if component:                # Set properties                if component_id:                    component.id = component_id                component.position = position                component.set_rotation(rotation)            return component        return create_component_from_dict