"""Circuit Simulator - Wires-----------------------This module defines wire connections between components."""import uuidimport loggingfrom components.base_component import BaseComponentimport configlogger = logging.getLogger(__name__)class Wire(BaseComponent):    """Wire connection between components."""    def __init__(self, start_component, start_connection, end_component, end_connection,                 component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a wire.        Args:            start_component: Starting component            start_connection: Starting connection name            end_component: Ending component            end_connection: Ending connection name            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        # Store references to connected components        self.start_component = start_component        self.start_connection = start_connection        self.end_component = end_component        self.end_connection = end_connection        # Wires have special sizing - they adapt to the distance between components        self._update_size()    def _init_connections(self):        """Initialize the connection points.        Wires don't have their own connection points, they just relay        connections between the components they connect.        """        self.connections = {}    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'start': 0.0, 'end': 0.0},            'currents': {'start': 0.0, 'end': 0.0},            'resistance': 0.001  # Minimal wire resistance        }    def _update_size(self):        """Update the size based on the distance between connected components."""        if not hasattr(self, 'start_component') or not hasattr(self, 'end_component'):            return        # Get the positions of the connections        start_pos = self._get_connection_position(self.start_component, self.start_connection)        end_pos = self._get_connection_position(self.end_component, self.end_connection)        if start_pos and end_pos:            # Calculate the distance between the connections            dx = end_pos[0] - start_pos[0]            dy = end_pos[1] - start_pos[1]            # Update the size            self.size = (abs(dx) + 1, abs(dy) + 1)            # Update the position to the midpoint            self.position = (                min(start_pos[0], end_pos[0]) + abs(dx) // 2,                min(start_pos[1], end_pos[1]) + abs(dy) // 2            )    def _get_connection_position(self, component, connection_name):        """Get the position of a connection point.        Args:            component: Component object            connection_name: Connection name        Returns:            (x, y) tuple of grid coordinates or None if not found        """        if not component or not connection_name:            return None        # Get the connection points from the component        connection_points = component.connection_points        # Check if the connection exists        if connection_name in connection_points:            return connection_points[connection_name]        return None    def calculate(self, simulator, time_step):        """Calculate the wire state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get the voltage at each end        start_voltage = self.start_component.get_voltage(self.start_connection)        end_voltage = self.end_component.get_voltage(self.end_connection)        # Get the resistance        resistance = self.get_property('resistance', 0.001)        # Calculate current through the wire (Ohm's Law)        if resistance > 0:            current = (start_voltage - end_voltage) / resistance        else:            current = 0.0        # Update the state        state_updates = {            'voltages': {'start': start_voltage, 'end': end_voltage},            'currents': {'start': current, 'end': -current},  # Current in = current out            'resistance': resistance        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass JumperWire(Wire):    """Jumper wire that crosses over other wires."""    def __init__(self, start_component, start_connection, end_component, end_connection,                 component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a jumper wire.        Args:            start_component: Starting component            start_connection: Starting connection name            end_component: Ending component            end_connection: Ending connection name            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(start_component, start_connection, end_component, end_connection,                         component_id, position, rotation, properties)class BusWire(Wire):    """Multi-line bus wire for connecting multiple signals."""    def __init__(self, start_component, start_connections, end_component, end_connections,                 component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a bus wire.        Args:            start_component: Starting component            start_connections: List of starting connection names            end_component: Ending component            end_connections: List of ending connection names            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        # Initialize with the first connection        if start_connections and end_connections:            super().__init__(start_component, start_connections[0], end_component, end_connections[0],                             component_id, position, rotation, properties)            # Store all connections            self.start_connections = start_connections            self.end_connections = end_connections        else:            raise ValueError("Bus wire requires at least one connection on each end")    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {},            'currents': {},            'resistance': 0.001  # Minimal wire resistance        }        # Initialize voltages and currents for each connection        for i, conn in enumerate(self.start_connections):            self.state['voltages'][f'start_{i}'] = 0.0            self.state['currents'][f'start_{i}'] = 0.0        for i, conn in enumerate(self.end_connections):            self.state['voltages'][f'end_{i}'] = 0.0            self.state['currents'][f'end_{i}'] = 0.0    def calculate(self, simulator, time_step):        """Calculate the bus wire state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        state_updates = {            'voltages': {},            'currents': {},            'resistance': self.get_property('resistance', 0.001)        }        # Calculate voltage and current for each connection        for i, start_conn in enumerate(self.start_connections):            if i < len(self.end_connections):                end_conn = self.end_connections[i]                # Get the voltage at each end                start_voltage = self.start_component.get_voltage(start_conn)                end_voltage = self.end_component.get_voltage(end_conn)                # Calculate current                resistance = state_updates['resistance']                if resistance > 0:                    current = (start_voltage - end_voltage) / resistance                else:                    current = 0.0                # Update state                state_updates['voltages'][f'start_{i}'] = start_voltage                state_updates['voltages'][f'end_{i}'] = end_voltage                state_updates['currents'][f'start_{i}'] = current                state_updates['currents'][f'end_{i}'] = -current        return state_updates