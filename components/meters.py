"""Circuit Simulator - Measurement Components----------------------------------------This module defines measurement components such as voltmeters, ammeters,oscilloscopes, and other test equipment."""import mathimport loggingimport numpy as npfrom collections import dequefrom components.base_component import BaseComponentimport configlogger = logging.getLogger(__name__)class Voltmeter(BaseComponent):    """Voltmeter component for measuring voltage."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a voltmeter.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (2, 1)  # Size in grid cells    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'p1': (-1, 0),  # Positive terminal (left)            'p2': (1, 0)    # Negative terminal (right)        }    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'p1': 0.0, 'p2': 0.0},            'currents': {'p1': 0.0, 'p2': 0.0},            'measurement': 0.0,  # Measured voltage            'history': deque(maxlen=100)  # Store recent measurements        }    def calculate(self, simulator, time_step):        """Calculate the voltmeter state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        internal_resistance = self.get_property('internal_resistance', 1e7)  # Very high resistance (10MΩ)        max_voltage = self.get_property('max_voltage', 50.0)        # Get connected components        node_p1 = simulator.get_node_for_component(self.id, 'p1')        node_p2 = simulator.get_node_for_component(self.id, 'p2')        # Get node voltages        v_p1 = node_p1.voltage if node_p1 else 0.0        v_p2 = node_p2.voltage if node_p2 else 0.0        # Calculate voltage across the meter        voltage_drop = v_p1 - v_p2        # Limit to max voltage if specified        if max_voltage > 0:            if voltage_drop > max_voltage:                voltage_drop = max_voltage            elif voltage_drop < -max_voltage:                voltage_drop = -max_voltage        # Calculate current through meter (minimal due to high internal resistance)        current = voltage_drop / internal_resistance if internal_resistance > 0 else 0.0        # Add measurement to history        measurement_record = {            'time': simulator.simulation_time,            'voltage': voltage_drop        }        history = list(self.state.get('history', []))        history.append(measurement_record)        if len(history) > 100:  # Limit history size            history.pop(0)        # Update the state        state_updates = {            'voltages': {'p1': v_p1, 'p2': v_p2},            'currents': {'p1': current, 'p2': -current},            'measurement': voltage_drop,            'history': history        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass Ammeter(BaseComponent):    """Ammeter component for measuring current."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize an ammeter.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (2, 1)  # Size in grid cells    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'p1': (-1, 0),  # Input terminal (left)            'p2': (1, 0)    # Output terminal (right)        }    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'p1': 0.0, 'p2': 0.0},            'currents': {'p1': 0.0, 'p2': 0.0},            'measurement': 0.0,  # Measured current            'history': deque(maxlen=100)  # Store recent measurements        }    def calculate(self, simulator, time_step):        """Calculate the ammeter state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        internal_resistance = self.get_property('internal_resistance', 0.1)  # Very low resistance (0.1Ω)        max_current = self.get_property('max_current', 10.0)        # Get connected components        node_p1 = simulator.get_node_for_component(self.id, 'p1')        node_p2 = simulator.get_node_for_component(self.id, 'p2')        # Get node voltages        v_p1 = node_p1.voltage if node_p1 else 0.0        v_p2 = node_p2.voltage if node_p2 else 0.0        # Calculate voltage across the meter        voltage_drop = v_p1 - v_p2        # Calculate current through meter (V=IR, so I=V/R)        current = voltage_drop / internal_resistance if internal_resistance > 0 else 0.0        # Limit to max current if specified        if max_current > 0:            if current > max_current:                current = max_current            elif current < -max_current:                current = -max_current        # Add measurement to history        measurement_record = {            'time': simulator.simulation_time,            'current': current        }        history = list(self.state.get('history', []))        history.append(measurement_record)        if len(history) > 100:  # Limit history size            history.pop(0)        # Update the state        state_updates = {            'voltages': {'p1': v_p1, 'p2': v_p2},            'currents': {'p1': current, 'p2': -current},            'measurement': current,            'history': history        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass Oscilloscope(BaseComponent):    """Oscilloscope component for visualizing signals over time."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize an oscilloscope.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (4, 3)  # Size in grid cells - oscilloscopes are bigger    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'ch1': (-1.5, 1),   # Channel 1 probe            'ch2': (-0.5, 1),   # Channel 2 probe            'gnd': (0.5, 1)     # Ground reference        }    def _init_state(self):        """Initialize the component state."""        # Initialize with default settings        time_base = self.get_property('time_base', 1e-3)  # 1ms/div default        v_scale_ch1 = self.get_property('v_scale_ch1', 1.0)  # 1V/div default        v_scale_ch2 = self.get_property('v_scale_ch2', 1.0)        trigger_level = self.get_property('trigger_level', 0.0)        trigger_channel = self.get_property('trigger_channel', 'ch1')        trigger_edge = self.get_property('trigger_edge', 'rising')        self.state = {            'voltages': {'ch1': 0.0, 'ch2': 0.0, 'gnd': 0.0},            'currents': {'ch1': 0.0, 'ch2': 0.0, 'gnd': 0.0},            'settings': {                'time_base': time_base,                'v_scale_ch1': v_scale_ch1,                'v_scale_ch2': v_scale_ch2,                'trigger_level': trigger_level,                'trigger_channel': trigger_channel,                'trigger_edge': trigger_edge,                'running': False            },            'ch1_history': deque(maxlen=1000),  # Longer history for oscilloscope            'ch2_history': deque(maxlen=1000),            'triggered': False,            'trigger_time': 0.0,            'display_data': []  # Data for the current display        }    def calculate(self, simulator, time_step):        """Calculate the oscilloscope state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get connected components        node_ch1 = simulator.get_node_for_component(self.id, 'ch1')        node_ch2 = simulator.get_node_for_component(self.id, 'ch2')        node_gnd = simulator.get_node_for_component(self.id, 'gnd')        # Get node voltages        v_ch1 = node_ch1.voltage if node_ch1 else 0.0        v_ch2 = node_ch2.voltage if node_ch2 else 0.0        v_gnd = node_gnd.voltage if node_gnd else 0.0        # Calculate relative voltages (relative to ground)        v_ch1_rel = v_ch1 - v_gnd        v_ch2_rel = v_ch2 - v_gnd        # Get internal resistance and calculate minimal currents        internal_resistance = self.get_property('internal_resistance', 1e7)  # 10MΩ        i_ch1 = v_ch1_rel / internal_resistance if internal_resistance > 0 else 0.0        i_ch2 = v_ch2_rel / internal_resistance if internal_resistance > 0 else 0.0        i_gnd = -(i_ch1 + i_ch2)  # Current into ground is negative of total current out        # Get settings        settings = self.state.get('settings', {})        trigger_level = settings.get('trigger_level', 0.0)        trigger_channel = settings.get('trigger_channel', 'ch1')        trigger_edge = settings.get('trigger_edge', 'rising')        running = settings.get('running', False)        # Add measurements to history        ch1_record = {            'time': simulator.simulation_time,            'voltage': v_ch1_rel        }        ch2_record = {            'time': simulator.simulation_time,            'voltage': v_ch2_rel        }        ch1_history = list(self.state.get('ch1_history', []))        ch1_history.append(ch1_record)        ch2_history = list(self.state.get('ch2_history', []))        ch2_history.append(ch2_record)        # Check for trigger condition if not already triggered        triggered = self.state.get('triggered', False)        trigger_time = self.state.get('trigger_time', 0.0)        if running and not triggered:            # Get trigger signal            trigger_signal = v_ch1_rel if trigger_channel == 'ch1' else v_ch2_rel            # Check if previous history point exists            if len(ch1_history) > 1 or len(ch2_history) > 1:                # Get previous signal value                if trigger_channel == 'ch1' and len(ch1_history) > 1:                    prev_signal = ch1_history[-2]['voltage']                elif trigger_channel == 'ch2' and len(ch2_history) > 1:                    prev_signal = ch2_history[-2]['voltage']                else:                    prev_signal = trigger_signal                # Check for trigger condition                if trigger_edge == 'rising' and prev_signal <= trigger_level < trigger_signal:                    triggered = True                    trigger_time = simulator.simulation_time                elif trigger_edge == 'falling' and prev_signal >= trigger_level > trigger_signal:                    triggered = True                    trigger_time = simulator.simulation_time        # Update the state        state_updates = {            'voltages': {'ch1': v_ch1, 'ch2': v_ch2, 'gnd': v_gnd},            'currents': {'ch1': i_ch1, 'ch2': i_ch2, 'gnd': i_gnd},            'ch1_history': ch1_history,            'ch2_history': ch2_history,            'triggered': triggered,            'trigger_time': trigger_time        }        # Generate display data if triggered        if triggered:            # Calculate time window based on time_base setting            time_base = settings.get('time_base', 1e-3)  # Default 1ms/div            time_window = time_base * 10  # 10 divisions horizontally            # If we have enough data after the trigger point, generate display data            current_time = simulator.simulation_time            if current_time - trigger_time >= time_window:                display_data = self._generate_display_data(                    ch1_history, ch2_history,                    trigger_time, time_window,                    settings                )                state_updates['display_data'] = display_data                # Reset trigger for next acquisition                state_updates['triggered'] = False        return state_updates    def _generate_display_data(self, ch1_history, ch2_history, trigger_time, time_window, settings):        """Generate display data for the oscilloscope screen.        Args:            ch1_history: History data for channel 1            ch2_history: History data for channel 2            trigger_time: Time of trigger event            time_window: Time window to display (seconds)            settings: Oscilloscope settings        Returns:            Dictionary with display data        """        # Filter history to include only data within the display window        display_start = trigger_time        display_end = trigger_time + time_window        ch1_display = [            record for record in ch1_history            if display_start <= record['time'] <= display_end        ]        ch2_display = [            record for record in ch2_history            if display_start <= record['time'] <= display_end        ]        # Scale voltages according to v_scale settings        v_scale_ch1 = settings.get('v_scale_ch1', 1.0)        v_scale_ch2 = settings.get('v_scale_ch2', 1.0)        # Generate display data        display_data = {            'ch1': {                'times': [record['time'] - display_start for record in ch1_display],                'voltages': [record['voltage'] for record in ch1_display],                'v_scale': v_scale_ch1            },            'ch2': {                'times': [record['time'] - display_start for record in ch2_display],                'voltages': [record['voltage'] for record in ch2_display],                'v_scale': v_scale_ch2            },            'time_base': settings.get('time_base', 1e-3),            'trigger_time': 0.0,  # Relative to display_start            'trigger_level': settings.get('trigger_level', 0.0)        }        return display_data    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = values    def start(self):        """Start the oscilloscope acquisition."""        self.state['settings']['running'] = True        self.state['triggered'] = False    def stop(self):        """Stop the oscilloscope acquisition."""        self.state['settings']['running'] = False    def set_timebase(self, time_base):        """Set the time base (seconds per division).        Args:            time_base: Time per division in seconds        """        self.state['settings']['time_base'] = time_base    def set_vscale(self, channel, v_scale):        """Set the voltage scale (volts per division).        Args:            channel: Channel number (1 or 2)            v_scale: Volts per division        """        if channel == 1:            self.state['settings']['v_scale_ch1'] = v_scale        elif channel == 2:            self.state['settings']['v_scale_ch2'] = v_scale    def set_trigger(self, level, channel='ch1', edge='rising'):        """Set the trigger settings.        Args:            level: Trigger voltage level            channel: Trigger channel ('ch1' or 'ch2')            edge: Trigger edge ('rising' or 'falling')        """        self.state['settings']['trigger_level'] = level        self.state['settings']['trigger_channel'] = channel        self.state['settings']['trigger_edge'] = edge        self.state['triggered'] = Falseclass MultimeterMode:    """Modes for the multimeter."""    DC_VOLTAGE = 'dc_voltage'    AC_VOLTAGE = 'ac_voltage'    DC_CURRENT = 'dc_current'    AC_CURRENT = 'ac_current'    RESISTANCE = 'resistance'    CONTINUITY = 'continuity'    DIODE = 'diode'    CAPACITANCE = 'capacitance'    FREQUENCY = 'frequency'class Multimeter(BaseComponent):    """Multimeter component for various electrical measurements."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a multimeter.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (3, 2)  # Size in grid cells    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'com': (-1, 0),     # Common/ground terminal            'v_ohm': (0, 0),    # Voltage/resistance terminal            'current': (1, 0)   # Current terminal        }    def _init_state(self):        """Initialize the component state."""        # Get default mode from properties        mode = self.get_property('mode', MultimeterMode.DC_VOLTAGE)        self.state = {            'voltages': {'com': 0.0, 'v_ohm': 0.0, 'current': 0.0},            'currents': {'com': 0.0, 'v_ohm': 0.0, 'current': 0.0},            'mode': mode,            'measurement': 0.0,            'range_auto': True,            'range': 0,  # 0 = auto range            'hold': False,            'min_value': None,            'max_value': None,            'history': deque(maxlen=100)        }    def calculate(self, simulator, time_step):        """Calculate the multimeter state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get node voltages        node_com = simulator.get_node_for_component(self.id, 'com')        node_v_ohm = simulator.get_node_for_component(self.id, 'v_ohm')        node_current = simulator.get_node_for_component(self.id, 'current')        v_com = node_com.voltage if node_com else 0.0        v_v_ohm = node_v_ohm.voltage if node_v_ohm else 0.0        v_current = node_current.voltage if node_current else 0.0        # Get current mode        mode = self.state.get('mode', MultimeterMode.DC_VOLTAGE)        # Calculate currents and measurement based on mode        currents = {'com': 0.0, 'v_ohm': 0.0, 'current': 0.0}        measurement = 0.0        if mode == MultimeterMode.DC_VOLTAGE:            # For voltage measurement, use high internal resistance            internal_resistance = 10e6  # 10MΩ            # Calculate voltage between v_ohm and com            voltage = v_v_ohm - v_com            # Calculate minimal current due to internal resistance            i_v_ohm = voltage / internal_resistance            i_com = -i_v_ohm            currents['v_ohm'] = i_v_ohm            currents['com'] = i_com            measurement = voltage        elif mode == MultimeterMode.AC_VOLTAGE:            # For AC voltage, we need to track the signal over time            # For now, just use a simplified calculation            internal_resistance = 10e6  # 10MΩ            # Calculate voltage between v_ohm and com            voltage = v_v_ohm - v_com            # Calculate minimal current due to internal resistance            i_v_ohm = voltage / internal_resistance            i_com = -i_v_ohm            currents['v_ohm'] = i_v_ohm            currents['com'] = i_com            # For AC, we would calculate RMS over a period            # For now, just use the instantaneous value            measurement = voltage        elif mode == MultimeterMode.DC_CURRENT:            # For current measurement, use very low internal resistance            internal_resistance = 0.1  # 0.1Ω            # Calculate voltage between current and com            voltage = v_current - v_com            # Calculate current through the meter            current = voltage / internal_resistance            currents['current'] = current            currents['com'] = -current            measurement = current        elif mode == MultimeterMode.RESISTANCE:            # For resistance measurement, meter sources a small current            # and measures resulting voltage            test_current = 1e-3  # 1mA test current            # Calculate voltage between v_ohm and com            voltage = v_v_ohm - v_com            # Current flows from com to v_ohm for resistance measurement            currents['com'] = test_current            currents['v_ohm'] = -test_current            # Calculate resistance (R = V/I)            if abs(test_current) > 1e-9:  # Avoid division by near-zero                resistance = voltage / test_current                measurement = resistance            else:                measurement = float('inf')  # Open circuit        # Add measurement to history        measurement_record = {            'time': simulator.simulation_time,            'value': measurement,            'mode': mode        }        history = list(self.state.get('history', []))        history.append(measurement_record)        # Update min/max values        min_value = self.state.get('min_value')        max_value = self.state.get('max_value')        if min_value is None or measurement < min_value:            min_value = measurement        if max_value is None or measurement > max_value:            max_value = measurement        # Update the state        state_updates = {            'voltages': {'com': v_com, 'v_ohm': v_v_ohm, 'current': v_current},            'currents': currents,            'measurement': measurement,            'history': history,            'min_value': min_value,            'max_value': max_value        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = values    def set_mode(self, mode):        """Set the multimeter mode.        Args:            mode: Mode from MultimeterMode enum        """        self.state['mode'] = mode        self.state['min_value'] = None        self.state['max_value'] = None        # Different internal resistances based on mode        if mode in [MultimeterMode.DC_VOLTAGE, MultimeterMode.AC_VOLTAGE]:            self.set_property('internal_resistance', 10e6)  # 10MΩ        elif mode in [MultimeterMode.DC_CURRENT, MultimeterMode.AC_CURRENT]:            self.set_property('internal_resistance', 0.1)  # 0.1Ω    def hold(self):        """Toggle the hold function."""        self.state['hold'] = not self.state.get('hold', False)    def reset_min_max(self):        """Reset the min/max values."""        self.state['min_value'] = None        self.state['max_value'] = None