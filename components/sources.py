"""Circuit Simulator - Source Components-----------------------------------This module defines voltage and current source components."""import mathimport loggingimport numpy as npfrom components.base_component import BaseComponentimport configlogger = logging.getLogger(__name__)class VoltageSource(BaseComponent):    """Base class for voltage sources."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a voltage source.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (2, 3)  # Size in grid cells    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'pos': (0, 1),   # Positive terminal (top)            'neg': (0, -1)   # Negative terminal (bottom)        }    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'pos': 0.0, 'neg': 0.0},            'currents': {'pos': 0.0, 'neg': 0.0},            'power': 0.0        }class DCVoltageSource(VoltageSource):    """DC Voltage source component."""    def calculate(self, simulator, time_step):        """Calculate the voltage source state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        voltage = self.get_property('voltage', config.DEFAULT_VOLTAGE)        max_current = self.get_property('max_current', 1.0)        # Get connected components        node_pos = simulator.get_node_for_component(self.id, 'pos')        node_neg = simulator.get_node_for_component(self.id, 'neg')        # For a voltage source, we set the voltages directly        v_pos = voltage        v_neg = 0.0        # Current is calculated by the simulator based on the attached circuit        # For now, we'll just use a placeholder        current = simulator.get_current_for_component(self.id, 'pos')        # Apply current limiting if needed        if abs(current) > max_current:            current = max_current if current > 0 else -max_current        # Calculate power        power = voltage * current        # Update the state        state_updates = {            'voltages': {'pos': v_pos, 'neg': v_neg},            'currents': {'pos': current, 'neg': -current},            'power': power        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass ACVoltageSource(VoltageSource):    """AC Voltage source component."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize an AC voltage source.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        # Initial simulation time        self.simulation_time = 0.0    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'pos': 0.0, 'neg': 0.0},            'currents': {'pos': 0.0, 'neg': 0.0},            'power': 0.0,            'instantaneous_voltage': 0.0,            'time': 0.0        }    def calculate(self, simulator, time_step):        """Calculate the AC voltage source state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        amplitude = self.get_property('amplitude', config.DEFAULT_VOLTAGE)        frequency = self.get_property('frequency', config.DEFAULT_FREQUENCY)        phase = self.get_property('phase', 0.0)  # Phase in degrees        max_current = self.get_property('max_current', 1.0)        # Update simulation time        self.simulation_time += time_step        # Calculate angular frequency (omega)        omega = 2 * math.pi * frequency        # Calculate instantaneous voltage: v(t) = A * sin(ωt + φ)        phase_rad = math.radians(phase)        voltage = amplitude * math.sin(omega * self.simulation_time + phase_rad)        # For an AC source, we set the voltages directly        v_pos = voltage        v_neg = 0.0        # Current is calculated by the simulator based on the attached circuit        current = simulator.get_current_for_component(self.id, 'pos')        # Apply current limiting if needed        if abs(current) > max_current:            current = max_current if current > 0 else -max_current        # Calculate power (instantaneous)        power = voltage * current        # Update the state        state_updates = {            'voltages': {'pos': v_pos, 'neg': v_neg},            'currents': {'pos': current, 'neg': -current},            'power': power,            'instantaneous_voltage': voltage,            'time': self.simulation_time        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass CurrentSource(BaseComponent):    """Base class for current sources."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a current source.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        self.size = (2, 3)  # Size in grid cells    def _init_connections(self):        """Initialize the connection points."""        # Define connection points relative to component position        self.connections = {            'pos': (0, 1),   # Positive terminal (current flows out)            'neg': (0, -1)   # Negative terminal (current flows in)        }    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'pos': 0.0, 'neg': 0.0},            'currents': {'pos': 0.0, 'neg': 0.0},            'power': 0.0        }class DCCurrentSource(CurrentSource):    """DC Current source component."""    def calculate(self, simulator, time_step):        """Calculate the current source state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        current = self.get_property('current', config.DEFAULT_CURRENT)        max_voltage = self.get_property('max_voltage', 12.0)        # Get connected components        node_pos = simulator.get_node_for_component(self.id, 'pos')        node_neg = simulator.get_node_for_component(self.id, 'neg')        # Get node voltages        v_pos = node_pos.voltage if node_pos else 0.0        v_neg = node_neg.voltage if node_neg else 0.0        # Calculate voltage across the source        voltage_drop = v_pos - v_neg        # Check if voltage exceeds maximum (compliance voltage)        if abs(voltage_drop) > max_voltage:            # Current source becomes voltage limited            voltage_drop = max_voltage if voltage_drop > 0 else -max_voltage            v_pos = v_neg + voltage_drop            current = voltage_drop / simulator.get_resistance_between(self.id, 'pos', 'neg')        # Calculate power        power = voltage_drop * current        # Update the state        state_updates = {            'voltages': {'pos': v_pos, 'neg': v_neg},            'currents': {'pos': current, 'neg': -current},            'power': power        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass ACCurrentSource(CurrentSource):    """AC Current source component."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize an AC current source.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        # Initial simulation time        self.simulation_time = 0.0    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'pos': 0.0, 'neg': 0.0},            'currents': {'pos': 0.0, 'neg': 0.0},            'power': 0.0,            'instantaneous_current': 0.0,            'time': 0.0        }    def calculate(self, simulator, time_step):        """Calculate the AC current source state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        amplitude = self.get_property('amplitude', config.DEFAULT_CURRENT)        frequency = self.get_property('frequency', config.DEFAULT_FREQUENCY)        phase = self.get_property('phase', 0.0)  # Phase in degrees        max_voltage = self.get_property('max_voltage', 12.0)        # Update simulation time        self.simulation_time += time_step        # Calculate angular frequency (omega)        omega = 2 * math.pi * frequency        # Calculate instantaneous current: i(t) = A * sin(ωt + φ)        phase_rad = math.radians(phase)        current = amplitude * math.sin(omega * self.simulation_time + phase_rad)        # Get connected components        node_pos = simulator.get_node_for_component(self.id, 'pos')        node_neg = simulator.get_node_for_component(self.id, 'neg')        # Get node voltages        v_pos = node_pos.voltage if node_pos else 0.0        v_neg = node_neg.voltage if node_neg else 0.0        # Calculate voltage across the source        voltage_drop = v_pos - v_neg        # Check if voltage exceeds maximum (compliance voltage)        if abs(voltage_drop) > max_voltage:            # Current source becomes voltage limited            voltage_drop = max_voltage if voltage_drop > 0 else -max_voltage            v_pos = v_neg + voltage_drop            current = voltage_drop / simulator.get_resistance_between(self.id, 'pos', 'neg')        # Calculate power (instantaneous)        power = voltage_drop * current        # Update the state        state_updates = {            'voltages': {'pos': v_pos, 'neg': v_neg},            'currents': {'pos': current, 'neg': -current},            'power': power,            'instantaneous_current': current,            'time': self.simulation_time        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass FunctionGenerator(VoltageSource):    """Function generator component with multiple waveform types."""    WAVEFORM_SINE = 'sine'    WAVEFORM_SQUARE = 'square'    WAVEFORM_TRIANGLE = 'triangle'    WAVEFORM_SAWTOOTH = 'sawtooth'    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a function generator.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)        # Initial simulation time        self.simulation_time = 0.0    def _init_state(self):        """Initialize the component state."""        self.state = {            'voltages': {'pos': 0.0, 'neg': 0.0},            'currents': {'pos': 0.0, 'neg': 0.0},            'power': 0.0,            'instantaneous_voltage': 0.0,            'time': 0.0        }    def calculate(self, simulator, time_step):        """Calculate the function generator state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Get component values        amplitude = self.get_property('amplitude', config.DEFAULT_VOLTAGE)        frequency = self.get_property('frequency', config.DEFAULT_FREQUENCY)        phase = self.get_property('phase', 0.0)  # Phase in degrees        waveform = self.get_property('waveform', self.WAVEFORM_SINE)        duty_cycle = self.get_property('duty_cycle', 0.5)  # For square wave        max_current = self.get_property('max_current', 1.0)        # Clamp duty cycle between 0 and 1        duty_cycle = max(0.0, min(1.0, duty_cycle))        # Update simulation time        self.simulation_time += time_step        # Calculate angular frequency (omega)        omega = 2 * math.pi * frequency        # Calculate instantaneous voltage based on waveform type        phase_rad = math.radians(phase)        phase_offset = omega * self.simulation_time + phase_rad        if waveform == self.WAVEFORM_SINE:            # Sine wave: v(t) = A * sin(ωt + φ)            voltage = amplitude * math.sin(phase_offset)        elif waveform == self.WAVEFORM_SQUARE:            # Square wave with duty cycle            cycle_position = (phase_offset / (2 * math.pi)) % 1.0            voltage = amplitude if cycle_position < duty_cycle else -amplitude        elif waveform == self.WAVEFORM_TRIANGLE:            # Triangle wave            cycle_position = (phase_offset / (2 * math.pi)) % 1.0            if cycle_position < 0.5:                # Rising part                voltage = amplitude * (4 * cycle_position - 1)            else:                # Falling part                voltage = amplitude * (3 - 4 * cycle_position)        elif waveform == self.WAVEFORM_SAWTOOTH:            # Sawtooth wave            cycle_position = (phase_offset / (2 * math.pi)) % 1.0            voltage = amplitude * (2 * cycle_position - 1)        else:            # Unknown waveform, use sine as fallback            voltage = amplitude * math.sin(phase_offset)        # For the function generator, we set the voltages directly        v_pos = voltage        v_neg = 0.0        # Current is calculated by the simulator based on the attached circuit        current = simulator.get_current_for_component(self.id, 'pos')        # Apply current limiting if needed        if abs(current) > max_current:            current = max_current if current > 0 else -max_current        # Calculate power (instantaneous)        power = voltage * current        # Update the state        state_updates = {            'voltages': {'pos': v_pos, 'neg': v_neg},            'currents': {'pos': current, 'neg': -current},            'power': power,            'instantaneous_voltage': voltage,            'time': self.simulation_time        }        return state_updates    def apply(self, state_updates):        """Apply state updates to the component.        Args:            state_updates: Dictionary of state updates        """        for category, values in state_updates.items():            if category in self.state:                if isinstance(values, dict):                    # Update nested dictionary                    for key, value in values.items():                        self.state[category][key] = value                else:                    # Update direct value                    self.state[category] = valuesclass Battery(DCVoltageSource):    """Battery component (DC voltage source with capacity)."""    def __init__(self, component_id=None, position=(0, 0), rotation=0, properties=None):        """Initialize a battery.        Args:            component_id: Database ID of the component type            position: (x, y) tuple of grid coordinates            rotation: Rotation in degrees (0, 90, 180, 270)            properties: Dictionary of component properties        """        super().__init__(component_id, position, rotation, properties)    def _init_state(self):        """Initialize the component state."""        # Inherit from DC voltage source        super()._init_state()        # Add battery-specific state        capacity = self.get_property('capacity', 1.0)  # Capacity in Ah        self.state.update({            'capacity': capacity,                     # Max capacity in Ah            'charge': capacity,                       # Current charge in Ah            'charge_percentage': 100.0,               # Charge percentage            'discharge_time': 0.0                     # Discharge time in seconds        })    def calculate(self, simulator, time_step):        """Calculate the battery state for the current time step.        Args:            simulator: CircuitSimulator instance            time_step: Time step in seconds        Returns:            Dictionary of updated state values        """        # Calculate the base state using the DC voltage source behavior        state_updates = super().calculate(simulator, time_step)        # Get battery-specific properties        capacity = self.get_property('capacity', 1.0)  # Capacity in Ah        internal_resistance = self.get_property('internal_resistance', 0.1)  # Internal resistance in ohms        # Get the current        current = state_updates['currents']['pos']        # Update charge based on current (Ah = A * h, so we convert time_step from seconds to hours)        charge_delta = current * (time_step / 3600.0)        new_charge = self.state['charge'] - charge_delta  # Positive current decreases charge        # Clamp charge between 0 and capacity        new_charge = max(0.0, min(capacity, new_charge))        # Calculate charge percentage        charge_percentage = (new_charge / capacity) * 100.0 if capacity > 0 else 0.0        # Update discharge time        if current > 0 and new_charge > 0:            # Time in hours = charge / current            discharge_time = new_charge / current if current > 0 else 0.0            # Convert to seconds            discharge_time_seconds = discharge_time * 3600.0        else:            discharge_time_seconds = 0.0        # Adjust voltage based on charge level and internal resistance        # Simple linear model: V = V_nominal * (charge_percentage / 100) - I * R_internal        nominal_voltage = self.get_property('voltage', config.DEFAULT_VOLTAGE)        adjusted_voltage = nominal_voltage * (charge_percentage / 100.0) - abs(current) * internal_resistance        # Update voltage in state        state_updates['voltages']['pos'] = max(0.0, adjusted_voltage)        # Add battery-specific state updates        state_updates.update({            'charge': new_charge,            'charge_percentage': charge_percentage,            'discharge_time': discharge_time_seconds        })        return state_updates